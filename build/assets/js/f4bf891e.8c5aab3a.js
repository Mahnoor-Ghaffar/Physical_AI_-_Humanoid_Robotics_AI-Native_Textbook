"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[1846],{497:(e,n,i)=>{i.d(n,{A:()=>s});i(6540);const t={calloutContainer:"calloutContainer_QbOl",trackLabel:"trackLabel_AGRY",content:"content_gVH3",isaacSim:"isaacSim_NZHJ",jetsonUnitree:"jetsonUnitree_gBDq",cloudCpu:"cloudCpu_bGMg",default:"default_p30M"};var r=i(4848);function s({track:e,children:n}){let i="";switch(e){case"Track A (Isaac Sim)":i=t.isaacSim;break;case"Track B (Jetson/Unitree)":i=t.jetsonUnitree;break;case"Track C (Cloud/CPU)":i=t.cloudCpu;break;default:i=t.default}return(0,r.jsxs)("div",{className:`${t.calloutContainer} ${i}`,children:[(0,r.jsx)("div",{className:t.trackLabel,children:e}),(0,r.jsx)("div",{className:t.content,children:n})]})}},1968:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>g,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"chapter3/index","title":"Chapter 3: Bridging Python AI Agents with rclpy","description":"Learn to integrate advanced Python-based AI agents, including LLMs and VLAs, with ROS 2 robotic systems using the powerful rclpy client library.","source":"@site/src/book-content/chapter3/index.mdx","sourceDirName":"chapter3","slug":"/chapter3/","permalink":"/docs/chapter3/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Chapter 3: Bridging Python AI Agents with rclpy","description":"Learn to integrate advanced Python-based AI agents, including LLMs and VLAs, with ROS 2 robotic systems using the powerful rclpy client library."},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2: Nodes, Topics, and Services","permalink":"/docs/chapter2/"},"next":{"title":"Chapter 4: Modeling Humanoids with URDF","permalink":"/docs/chapter4/"}}');var r=i(4848),s=i(8453),o=i(497);const l={title:"Chapter 3: Bridging Python AI Agents with rclpy",description:"Learn to integrate advanced Python-based AI agents, including LLMs and VLAs, with ROS 2 robotic systems using the powerful rclpy client library."},a=void 0,c={},d=[{value:"Chapter 3: Bridging Python AI Agents with rclpy",id:"chapter-3-bridging-python-ai-agents-with-rclpy",level:2},{value:"3.1 Objectives",id:"31-objectives",level:3},{value:"3.2 <code>rclpy</code> Deep Dive: Pythonic ROS 2 Development",id:"32-rclpy-deep-dive-pythonic-ros-2-development",level:3},{value:"3.3 ROS 2 Actions: Goal-Oriented Tasks",id:"33-ros-2-actions-goal-oriented-tasks",level:3},{value:"3.3.1 Action Server",id:"331-action-server",level:4},{value:"3.3.2 Action Client",id:"332-action-client",level:4},{value:"3.4 Asynchronous Programming in <code>rclpy</code>: Callbacks &amp; Executors",id:"34-asynchronous-programming-in-rclpy-callbacks--executors",level:3},{value:"3.5 Integrating External Python Libraries: LLMs/VLAs",id:"35-integrating-external-python-libraries-llmsvlas",level:3},{value:"Bridging High-Level AI to Low-Level Control",id:"bridging-high-level-ai-to-low-level-control",level:4},{value:"Handling External API Failure Modes",id:"handling-external-api-failure-modes",level:4},{value:"Worked Example 3.1: Designing a Custom Action for a Robot Arm Movement",id:"worked-example-31-designing-a-custom-action-for-a-robot-arm-movement",level:4},{value:"3.6 Type Hints and Threading Safety in <code>rclpy</code> Nodes",id:"36-type-hints-and-threading-safety-in-rclpy-nodes",level:3},{value:"3.7 Summary &amp; Key Takeaways",id:"37-summary--key-takeaways",level:3},{value:"3.8 Quiz &amp; Exercises",id:"38-quiz--exercises",level:3},{value:"Multiple Choice Questions",id:"multiple-choice-questions",level:4},{value:"Open-ended Question",id:"open-ended-question",level:4},{value:"3.9 References",id:"39-references",level:3}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"chapter-3-bridging-python-ai-agents-with-rclpy",children:"Chapter 3: Bridging Python AI Agents with rclpy"}),"\n",(0,r.jsx)(n.h3,{id:"31-objectives",children:"3.1 Objectives"}),"\n",(0,r.jsx)(n.p,{children:"Upon completing this chapter, you will be able to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Write robust ",(0,r.jsx)(n.code,{children:"rclpy"})," nodes specifically designed for integrating AI agents with ROS 2."]}),"\n",(0,r.jsx)(n.li,{children:"Bridge external Python scripts and libraries (e.g., those interacting with LLM or VLA APIs) to ROS 2 topics and actions."}),"\n",(0,r.jsxs)(n.li,{children:["Effectively handle asynchronous callbacks and manage concurrency within ",(0,r.jsx)(n.code,{children:"rclpy"})," nodes for responsive agent behavior."]}),"\n",(0,r.jsxs)(n.li,{children:["Apply Python type hints to improve the readability, maintainability, and reliability of your ",(0,r.jsx)(n.code,{children:"rclpy"})," code."]}),"\n",(0,r.jsx)(n.li,{children:"Implement ROS 2 action clients and servers in Python to manage goal-oriented tasks for AI-driven robots."}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"32-rclpy-deep-dive-pythonic-ros-2-development",children:["3.2 ",(0,r.jsx)(n.code,{children:"rclpy"})," Deep Dive: Pythonic ROS 2 Development"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"rclpy"})," is the official Python client library for ROS 2, providing a Pythonic interface to all core ROS 2 functionalities. It allows developers to write nodes, publishers, subscribers, service servers, service clients, action servers, and action clients using familiar Python syntax and paradigms. This makes ",(0,r.jsx)(n.code,{children:"rclpy"})," an ideal choice for integrating advanced AI algorithms, often developed in Python, directly into the ROS 2 ecosystem. The ",(0,r.jsx)(n.code,{children:"rclpy"})," library leverages the power of Python, including its robust data structures and rich ecosystem of AI/ML libraries, to enable rapid prototyping and deployment of intelligent robot behaviors. Understanding ",(0,r.jsx)(n.code,{children:"rclpy"}),"'s API structure, including how to initialize, spin, and destroy nodes, forms the foundation for building any Python-based ROS 2 application."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nimport time\n\nclass RclpyAgentNode(Node):\n    def __init__(self):\n        super().__init__('ai_agent_interface_node')\n        self.get_logger().info('AI Agent Interface Node started, ready to bridge AI to ROS 2.')\n        self.timer_ = self.create_timer(2.0, self.status_check_callback)\n        self.status_count = 0\n\n    def status_check_callback(self):\n        self.status_count += 1\n        self.get_logger().info(f'AI Agent Interface Node operational: {self.status_count} checks.')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    agent_node = RclpyAgentNode()\n    try:\n        rclpy.spin(agent_node)\n    except KeyboardInterrupt:\n        agent_node.get_logger().info('AI Agent Interface Node shutting down.')\n    finally:\n        agent_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Code Example 3.1"}),": A basic ",(0,r.jsx)(n.code,{children:"rclpy"})," node for an AI agent interface."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"33-ros-2-actions-goal-oriented-tasks",children:"3.3 ROS 2 Actions: Goal-Oriented Tasks"}),"\n",(0,r.jsxs)(n.p,{children:["For long-running and goal-oriented tasks, such as commanding a robot arm to pick up an object or a humanoid to walk to a destination, ROS 2 ",(0,r.jsx)(n.strong,{children:"Actions"})," provide a robust communication pattern. Actions extend the request/response model of services by adding periodic feedback and the ability to preempt (cancel) a goal. An Action involves three parts: a ",(0,r.jsx)(n.strong,{children:"Goal"})," (what the client wants to achieve), ",(0,r.jsx)(n.strong,{children:"Feedback"})," (periodic updates on the goal's progress), and a ",(0,r.jsx)(n.strong,{children:"Result"})," (the final outcome of the goal). This structured interaction is crucial for AI agents that need to monitor the execution of complex robot behaviors."]}),"\n",(0,r.jsx)(n.h4,{id:"331-action-server",children:"3.3.1 Action Server"}),"\n",(0,r.jsx)(n.p,{children:"An Action Server processes incoming goals, provides feedback, and eventually sends a result."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionServer\nfrom rclpy.node import Node\nfrom example_interfaces.action import Fibonacci # Example action definition\nimport time\n\nclass MinimalActionServer(Node):\n    def __init__(self):\n        super().__init__('minimal_action_server')\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            'fibonacci',\n            self.execute_callback)\n        self.get_logger().info('Fibonacci Action Server started.')\n\n    async def execute_callback(self, goal_handle):\n        self.get_logger().info(f'Executing goal: {goal_handle.request.order}')\n\n        feedback_msg = Fibonacci.Feedback()\n        feedback_msg.sequence = [0, 1]\n\n        # Compute Fibonacci sequence, providing feedback\n        for i in range(1, goal_handle.request.order):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info('Goal canceled.')\n                return Fibonacci.Result() # Return an empty result\n            \n            feedback_msg.sequence.append(feedback_msg.sequence[i-1] + feedback_msg.sequence[i])\n            self.get_logger().info(f'Feedback: {feedback_msg.sequence}')\n            goal_handle.publish_feedback(feedback_msg)\n            time.sleep(0.5) # Simulate work\n\n        goal_handle.succeed()\n        result = Fibonacci.Result()\n        result.sequence = feedback_msg.sequence\n        self.get_logger().info(f'Goal succeeded, result: {result.sequence}')\n        return result\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_action_server = MinimalActionServer()\n    rclpy.spin(minimal_action_server)\n    minimal_action_server.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Code Example 3.2"}),": A Python Action Server implementing the Fibonacci sequence."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"332-action-client",children:"3.3.2 Action Client"}),"\n",(0,r.jsx)(n.p,{children:"An Action Client sends a goal to an Action Server and processes feedback and the final result."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\nfrom example_interfaces.action import Fibonacci\nimport time\n\nclass MinimalActionClient(Node):\n    def __init__(self):\n        super().__init__('minimal_action_client')\n        self._action_client = ActionClient(self, Fibonacci, 'fibonacci')\n        self.get_logger().info('Fibonacci Action Client ready.')\n\n    def send_goal(self, order):\n        goal_msg = Fibonacci.Goal()\n        goal_msg.order = order\n\n        self.get_logger().info('Waiting for action server...')\n        self._action_client.wait_for_server()\n\n        self.get_logger().info(f'Sending goal request: {order}')\n        self._send_goal_future = self._action_client.send_goal_async(goal_msg, feedback_callback=self.feedback_callback)\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().warn('Goal rejected by server :(')\n            return\n\n        self.get_logger().info('Goal accepted by server :)')\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.get_result_callback)\n\n    def get_result_callback(self, future):\n        result = future.result().result\n        self.get_logger().info(f'Result: {result.sequence}')\n        rclpy.shutdown() # Shut down the rclpy context when goal is done\n\n    def feedback_callback(self, feedback_msg):\n        feedback = feedback_msg.feedback\n        self.get_logger().info(f'Received feedback: {feedback.sequence}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    action_client = MinimalActionClient()\n    action_client.send_goal(10) # Request Fibonacci sequence up to 10th element\n    rclpy.spin(action_client) # Keep spinning until goal completes\n    action_client.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Code Example 3.3"}),": A Python Action Client requesting the Fibonacci sequence."]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"34-asynchronous-programming-in-rclpy-callbacks--executors",children:["3.4 Asynchronous Programming in ",(0,r.jsx)(n.code,{children:"rclpy"}),": Callbacks & Executors"]}),"\n",(0,r.jsxs)(n.p,{children:["Robotics applications often require handling multiple events concurrently\u2014sensor data arriving, user commands, timer events, and more. ",(0,r.jsx)(n.code,{children:"rclpy"})," manages these concurrent operations through ",(0,r.jsx)(n.strong,{children:"callbacks"})," and ",(0,r.jsx)(n.strong,{children:"executors"}),". A callback is a function registered to be executed when a specific event occurs (e.g., a new message arrives on a topic). An ",(0,r.jsx)(n.strong,{children:"Executor"})," is responsible for spinning nodes and invoking their callbacks."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"SingleThreadedExecutor"})}),": This is the default. It processes all callbacks in a single thread sequentially. Simple and safe, but can block if a callback takes too long."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"MultiThreadedExecutor"})}),": This executor processes callbacks in multiple threads, allowing for true concurrency. It's suitable for nodes with long-running or blocking callbacks, but requires careful handling of shared resources to prevent race conditions."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Integration with ",(0,r.jsx)(n.code,{children:"asyncio"})]}),": For advanced Python asynchronous workflows, ",(0,r.jsx)(n.code,{children:"rclpy"})," can be integrated with Python's built-in ",(0,r.jsx)(n.code,{children:"asyncio"})," event loop. This allows ",(0,r.jsx)(n.code,{children:"rclpy"})," nodes to coexist and interact with other ",(0,r.jsx)(n.code,{children:"asyncio"}),"-based tasks, offering powerful patterns for complex AI agent integration."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom rclpy.executors import MultiThreadedExecutor\nfrom std_msgs.msg import String\nimport time\nimport asyncio\nimport threading\n\nclass AsyncNode(Node):\n    def __init__(self):\n        super().__init__(\'async_rclpy_node\')\n        self.publisher_ = self.create_publisher(String, \'ping\', 10)\n        self.subscription = self.create_subscription(String, \'pong\', self.pong_callback, 10)\n        self.timer_ = self.create_timer(1.0, self.ping_callback)\n        self.get_logger().info(\'Asynchronous rclpy node started.\')\n        self.last_ping_time = self.get_clock().now()\n\n    def ping_callback(self):\n        msg = String(data=f"Ping at {self.get_clock().now().nanoseconds}")\n        self.publisher_.publish(msg)\n        self.get_logger().info(f"Published: {msg.data}")\n\n    def pong_callback(self, msg):\n        self.get_logger().info(f"Received Pong: {msg.data}")\n        # Simulate a long-running, non-blocking task (e.g., AI inference)\n        time.sleep(0.1) # Shorter sleep to show non-blocking effect\n        self.get_logger().info(f"Finished processing pong: {msg.data}")\n\n# Example of an asyncio task coexisting\nasync def external_async_task():\n    for i in range(5):\n        print(f"External Async Task running... {i}")\n        await asyncio.sleep(0.7) # Simulate some other async work\n    print("External Async Task finished.")\n\ndef spin_rclpy_node(executor, node):\n    executor.add_node(node)\n    executor.spin()\n    executor.remove_node(node)\n    node.destroy_node()\n\nasync def main_async(args=None):\n    rclpy.init(args=args)\n    node = AsyncNode()\n    executor = MultiThreadedExecutor()\n\n    # Run rclpy executor in a separate thread\n    rclpy_thread = threading.Thread(target=spin_rclpy_node, args=(executor, node), daemon=True)\n    rclpy_thread.start()\n\n    # Run other asyncio tasks\n    await external_async_task()\n\n    rclpy.shutdown()\n\ndef main(args=None):\n    asyncio.run(main_async(args=args))\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Code Example 3.4"}),": ",(0,r.jsx)(n.code,{children:"rclpy"})," node using ",(0,r.jsx)(n.code,{children:"MultiThreadedExecutor"})," and coexisting with ",(0,r.jsx)(n.code,{children:"asyncio"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"35-integrating-external-python-libraries-llmsvlas",children:"3.5 Integrating External Python Libraries: LLMs/VLAs"}),"\n",(0,r.jsxs)(n.p,{children:["The true power of ",(0,r.jsx)(n.code,{children:"rclpy"})," in modern robotics lies in its ability to seamlessly integrate with external Python libraries, particularly those driving cutting-edge AI agents like Large Language Models (LLMs) and Vision-Language Assistants (VLAs). These agents can provide high-level cognitive capabilities, translating human commands into robotic actions or interpreting complex visual scenes."]}),"\n",(0,r.jsx)(n.h4,{id:"bridging-high-level-ai-to-low-level-control",children:"Bridging High-Level AI to Low-Level Control"}),"\n",(0,r.jsx)(n.p,{children:"A typical integration pattern involves:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Perception"}),": VLA processes sensor data (e.g., camera images) from ROS 2 topics, potentially outputting semantic understanding."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cognition"}),": LLM interprets human natural language commands, enriched by VLA perception, to generate a high-level robot goal."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Action Planning"}),": The ",(0,r.jsx)(n.code,{children:"rclpy"})," node translates this high-level goal into specific ROS 2 actions (e.g., move to a pose, grasp an object)."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"handling-external-api-failure-modes",children:"Handling External API Failure Modes"}),"\n",(0,r.jsx)(n.p,{children:"When integrating with external AI APIs (e.g., OpenAI, Google Gemini), reliability is paramount. The module will discuss conceptual strategies for handling API failure modes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Retries with Exponential Backoff"}),": Automatically re-attempting failed API calls after increasing delays."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Timeouts"}),": Setting limits on how long to wait for an API response to prevent blocking."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fallback Mechanisms"}),": Implementing alternative behaviors or simplified actions if an external API is unavailable or returns an error."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error Reporting"}),": Logging detailed errors for diagnostics and debugging."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# Conceptual Python script integrating with a mock LLM API and publishing to a ROS 2 topic\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\nimport time\nimport requests # Mocking external API call\n\nclass LLMInterfaceNode(Node):\n    def __init__(self):\n        super().__init__(\'llm_interface_node\')\n        self.cmd_publisher = self.create_publisher(String, \'robot_commands\', 10)\n        self.timer = self.create_timer(5.0, self.query_llm_callback)\n        self.get_logger().info(\'LLM Interface Node initialized.\')\n\n    def mock_llm_api_call(self, prompt):\n        # Simulate API call with potential failures\n        if time.time() % 10 < 2: # Simulate occasional API downtime\n            raise requests.exceptions.ConnectionError("Mock LLM API connection error")\n        if len(prompt) > 50 and time.time() % 7 < 3: # Simulate rate limit for long prompts\n            raise requests.exceptions.HTTPError("Mock LLM API rate limit exceeded")\n        \n        # Simulate LLM response\n        if "move forward" in prompt.lower():\n            return "MOVE_FORWARD_ACTION"\n        elif "wave hand" in prompt.lower():\n            return "WAVE_HAND_ACTION"\n        else:\n            return "UNKNOWN_ACTION"\n\n    def query_llm_callback(self):\n        # Example prompt (could come from a subscriber or internal logic)\n        prompt = "Please tell the robot to move forward a bit."\n        \n        try:\n            robot_action = self.mock_llm_api_call(prompt)\n            msg = String()\n            msg.data = robot_action\n            self.cmd_publisher.publish(msg)\n            self.get_logger().info(f\'Published ROS command: "{msg.data}" from LLM.\')\n        except (requests.exceptions.ConnectionError, requests.exceptions.HTTPError) as e:\n            self.get_logger().error(f"LLM API call failed: {e}. Implementing fallback behavior.")\n            # Fallback: Publish a safe stop command or log the error\n            fallback_msg = String(data="STOP_ROBOT_FALLBACK")\n            self.cmd_publisher.publish(fallback_msg)\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    llm_node = LLMInterfaceNode()\n    rclpy.spin(llm_node)\n    llm_node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Code Example 3.5"}),": Conceptual Python script integrating with a mock LLM API and publishing to a ROS 2 topic, including basic error handling."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"worked-example-31-designing-a-custom-action-for-a-robot-arm-movement",children:"Worked Example 3.1: Designing a Custom Action for a Robot Arm Movement"}),"\n",(0,r.jsxs)(n.p,{children:["(Placeholder for detailed example: This section will walk through defining a custom ",(0,r.jsx)(n.code,{children:".action"})," file for a robot arm movement (e.g., ",(0,r.jsx)(n.code,{children:"MoveArmToPose"}),"), generating the interfaces, and implementing a basic server and client.)"]}),"\n",(0,r.jsxs)(n.h3,{id:"36-type-hints-and-threading-safety-in-rclpy-nodes",children:["3.6 Type Hints and Threading Safety in ",(0,r.jsx)(n.code,{children:"rclpy"})," Nodes"]}),"\n",(0,r.jsxs)(n.p,{children:["As ",(0,r.jsx)(n.code,{children:"rclpy"})," applications grow in complexity, particularly when integrating AI agents that may involve heavy computation or external API calls, two aspects become critical: ",(0,r.jsx)(n.strong,{children:"Type Hints"})," and ",(0,r.jsx)(n.strong,{children:"Threading Safety"}),"."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Type Hints"}),": Python's type hinting, facilitated by the ",(0,r.jsx)(n.code,{children:"typing"})," module, greatly enhances the readability, maintainability, and reliability of ",(0,r.jsx)(n.code,{children:"rclpy"})," code. By annotating function arguments, return values, and class attributes with their expected types (including ROS 2 message types), developers can catch type-related errors early, improve IDE autocompletion, and make code easier to understand for collaborators."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from std_msgs.msg import String\nfrom example_interfaces.action import Fibonacci # type: ignore # Example, will be generated\nfrom rclpy.action import ActionClient, ClientGoalHandle\n\nclass TypeHintedNode(Node):\n    def __init__(self, node_name: str):\n        super().__init__(node_name)\n        self._action_client: ActionClient = ActionClient(self, Fibonacci, 'fibonacci')\n        self._send_goal_future: rclpy.task.Future = rclpy.task.Future()\n\n    def goal_response_callback(self, future: rclpy.task.Future) -> None:\n        goal_handle: ClientGoalHandle = future.result()\n        if goal_handle.accepted:\n            self.get_logger().info('Goal accepted :)')\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Code Example 3.6"}),": Example of using type hints in ",(0,r.jsx)(n.code,{children:"rclpy"})," code."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Threading Safety"}),": When using ",(0,r.jsx)(n.code,{children:"MultiThreadedExecutor"})," (as shown in Section 3.4), multiple callbacks can execute concurrently. This introduces the risk of ",(0,r.jsx)(n.strong,{children:"race conditions"})," if shared resources (e.g., node member variables like counters or state flags) are accessed and modified by multiple threads without proper synchronization. Python's ",(0,r.jsx)(n.code,{children:"threading"})," module provides mechanisms like ",(0,r.jsx)(n.code,{children:"Lock"})," and ",(0,r.jsx)(n.code,{children:"RLock"})," to protect shared data. Care must be taken to minimize blocking operations within critical sections."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(o.A,{track:"Track C (Cloud/CPU)",children:(0,r.jsx)(n.p,{children:"When running LLMs on powerful cloud CPUs and integrating them with ROS 2, efficient asynchronous processing and careful threading safety are crucial to maintain low latency between high-level AI decisions and robotic actions."})}),"\n",(0,r.jsx)(n.h3,{id:"37-summary--key-takeaways",children:"3.7 Summary & Key Takeaways"}),"\n",(0,r.jsxs)(n.p,{children:["Chapter 3 has delved into the powerful capabilities of ",(0,r.jsx)(n.code,{children:"rclpy"})," for bridging advanced Python-based AI agents with ROS 2 robotic systems. You've learned how to leverage ROS 2 Actions for complex, goal-oriented tasks, which are essential for AI-driven robot control. A deep understanding of asynchronous programming with ",(0,r.jsx)(n.code,{children:"rclpy"})," executors and integration with ",(0,r.jsx)(n.code,{children:"asyncio"})," has prepared you to build responsive and concurrent robot behaviors. Furthermore, you've explored best practices for code quality with type hints and ensuring threading safety, particularly vital when combining ",(0,r.jsx)(n.code,{children:"rclpy"})," with external AI libraries. This chapter empowers you to bring cutting-edge AI cognition and perception into the realm of physical robotics."]}),"\n",(0,r.jsx)(n.h3,{id:"38-quiz--exercises",children:"3.8 Quiz & Exercises"}),"\n",(0,r.jsx)(n.h4,{id:"multiple-choice-questions",children:"Multiple Choice Questions"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Which ",(0,r.jsx)(n.code,{children:"rclpy"})," communication primitive is designed for long-running, goal-oriented tasks that provide periodic feedback?"]}),"\na) Topics\nb) Services\nc) Actions\nd) Parameters"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["What is the primary benefit of using ",(0,r.jsx)(n.code,{children:"MultiThreadedExecutor"})," in ",(0,r.jsx)(n.code,{children:"rclpy"})," nodes compared to ",(0,r.jsx)(n.code,{children:"SingleThreadedExecutor"}),"?"]}),"\na) Guarantees message delivery order.\nb) Allows multiple callbacks to execute concurrently.\nc) Simplifies node initialization.\nd) Reduces memory usage."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"When integrating an external LLM API that might experience downtime, what is a recommended conceptual strategy for robust error handling?"}),"\na) Immediately crash the ROS 2 node.\nb) Implement retries with exponential backoff.\nc) Ignore API responses.\nd) Store all API calls locally."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["What role do Python type hints play in ",(0,r.jsx)(n.code,{children:"rclpy"})," development, especially when integrating AI agents?"]}),"\na) They directly optimize runtime performance.\nb) They improve code readability, maintainability, and enable static analysis.\nc) They automatically handle threading safety.\nd) They replace the need for ",(0,r.jsx)(n.code,{children:"rclpy.init()"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Which part of an ROS 2 Action provides updates on the goal's progress to the client?"}),"\na) Goal\nb) Result\nc) Feedback\nd) Request"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"open-ended-question",children:"Open-ended Question"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Describe how ",(0,r.jsx)(n.code,{children:"rclpy"})," nodes can leverage Python's ",(0,r.jsx)(n.code,{children:"asyncio"})," to integrate with complex AI agents that involve non-blocking external API calls. Discuss the benefits and potential challenges, including considerations for threading."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"39-references",children:"3.9 References"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["ROS 2 Documentation. (n.d.-a). ",(0,r.jsx)(n.em,{children:"About actions"}),". Retrieved from ",(0,r.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Concepts/About-Actions.html",children:"https://docs.ros.org/en/humble/Concepts/About-Actions.html"})]}),"\n",(0,r.jsxs)(n.li,{children:["ROS 2 Documentation. (n.d.-b). ",(0,r.jsx)(n.em,{children:"About executors"}),". Retrieved from ",(0,r.jsx)(n.a,{href:"https://docs.ros.org/en/humble/How-To-Guides/Using-Executors-in-rclpy.html",children:"https://docs.ros.org/en/humble/How-To-Guides/Using-Executors-in-rclpy.html"})]}),"\n",(0,r.jsxs)(n.li,{children:["Python Documentation. (n.d.-c). ",(0,r.jsxs)(n.em,{children:["The ",(0,r.jsx)(n.code,{children:"asyncio"})," module"]}),". Retrieved from ",(0,r.jsx)(n.a,{href:"https://docs.python.org/3/library/asyncio.html",children:"https://docs.python.org/3/library/asyncio.html"})]}),"\n",(0,r.jsxs)(n.li,{children:["Python Documentation. (n.d.-d). ",(0,r.jsx)(n.em,{children:"Type hinting"}),". Retrieved from ",(0,r.jsx)(n.a,{href:"https://docs.python.org/3/library/typing.html",children:"https://docs.python.org/3/library/typing.html"})]}),"\n",(0,r.jsxs)(n.li,{children:["Python Documentation. (n.d.-e). ",(0,r.jsx)(n.em,{children:"Threading synchronization primitives"}),". Retrieved from ",(0,r.jsx)(n.a,{href:"https://docs.python.org/3/library/threading.html#synchronization-primitives",children:"https://docs.python.org/3/library/threading.html#synchronization-primitives"})]}),"\n",(0,r.jsxs)(n.li,{children:["ROS 2 Documentation. (n.d.-f). ",(0,r.jsx)(n.em,{children:"Writing an Action Server and Client (Python)"}),". Retrieved from ",(0,r.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Action-Server-And-Client-Py.html",children:"https://docs.ros.org/en/humble/Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Action-Server-And-Client-Py.html"})]}),"\n",(0,r.jsxs)(n.li,{children:["OpenAI API Reference. (n.d.). ",(0,r.jsx)(n.em,{children:"API Usage Guidelines"}),". Retrieved from ",(0,r.jsx)(n.a,{href:"https://openai.com/docs/api-reference",children:"https://openai.com/docs/api-reference"})," (Cited as example of external API documentation)."]}),"\n"]})]})}function g(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var t=i(6540);const r={},s=t.createContext(r);function o(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);