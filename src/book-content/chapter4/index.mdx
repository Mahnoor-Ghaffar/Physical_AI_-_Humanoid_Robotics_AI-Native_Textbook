---
title: "Chapter 4: Modeling Humanoids with URDF"
description: "Master the art of describing robot kinematics, visual properties, and collision geometries using URDF and Xacro for simulation and control of humanoid robots."
---

import HardwareTrackCallout from '@site/src/components/HardwareTrackCallout';
import UrdfViewer from '@site/src/components/UrdfViewer'; // Assuming a component to visualize URDF

## Chapter 4: Modeling Humanoids with URDF

### 4.1 Objectives

Upon completing this chapter, you will be able to:
*   Author well-structured URDF (Unified Robot Description Format) and Xacro files to accurately describe humanoid robot kinematics and physical properties.
*   Effectively define links, joints, visual elements, and collision elements within URDF/Xacro models.
*   Utilize 3D mesh files (`.stl`, `.dae`) for precise robot geometry representation in models.
*   Visualize URDF models in RViz, inspecting their kinematic structure and coordinate frames.
*   Integrate URDF/Xacro models into dynamic simulation environments like Gazebo and NVIDIA Isaac Sim.
*   Understand the fundamental concepts of forward and inverse kinematics as they apply to humanoid robots.

### 4.2 Introduction to Robot Description: URDF & Xacro

To effectively control and simulate a robot, especially complex systems like humanoids, a precise digital description of its physical structure is indispensable. This is where **URDF (Unified Robot Description Format)** comes into play. URDF is an XML-based file format used in ROS to describe all elements of a robot, including its kinematic and dynamic properties, visual appearance, and collision characteristics. It defines the robot's rigid parts (links) and how they connect (joints), forming a kinematic chain.

While URDF is powerful, creating large and repetitive robot descriptions can become cumbersome. This is addressed by **Xacro (XML Macros for ROS)**. Xacro is an XML macro language that allows for more concise, modular, and readable URDF files. It enables the use of macros, properties, and mathematical expressions, making it easier to define symmetric structures (like a humanoid's left and right arms) and parameterize robot dimensions. Xacro files are processed to generate a standard URDF before being used by ROS 2 tools and simulators.

### 4.3 Defining Robot Links and Joints

The fundamental building blocks of any robot model in URDF are **links** and **joints**.
*   A **link** represents a rigid body part of the robot (e.g., a torso, a leg segment, an arm). Each link has physical properties like mass, inertia, and geometric descriptions for visualization and collision.
*   A **joint** describes the connection between two links, defining their relative motion. Common joint types include:
    *   `revolute`: Rotational joint with a limited range.
    *   `continuous`: Rotational joint with unlimited range.
    *   `prismatic`: Translational joint with a limited range.
    *   `fixed`: A rigid connection between two links (no relative motion).

The hierarchy of links connected by joints forms the **kinematic chain** of the robot. The origin of a joint defines its position and orientation relative to its parent link, and conversely, the child link's origin relative to the joint. This precise definition is crucial for accurate kinematics.

```xml
<?xml version="1.0"?>
<robot name="simple_arm_link" xmlns:xacro="http://ros.org/wiki/xacro">

  <xacro:macro name="arm_link" params="name length">
    <link name="${name}">
      <visual>
        <geometry>
          <box size="${length} 0.1 0.1"/>
        </geometry>
        <material name="blue">
          <color rgba="0 0 0.8 1"/>
        </material>
      </visual>
      <collision>
        <geometry>
          <box size="${length} 0.1 0.1"/>
        </geometry>
      </collision>
      <inertial>
        <mass value="1.0"/>
        <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.001"/>
      </inertial>
    </link>
  </xacro:macro>

  <xacro:arm_link name="forearm" length="0.3"/>

</robot>
```
*   **Code Example 4.1**: Simple Xacro file for a single link (e.g., a forearm).

```xml
<?xml version="1.0"?>
<robot name="two_dof_arm" xmlns:xacro="http://ros.org/wiki/xacro">

  <!-- Define a simple link macro -->
  <xacro:macro name="box_link" params="name mass_val size_x size_y size_z">
    <link name="${name}">
      <visual>
        <geometry><box size="${size_x} ${size_y} ${size_z}"/></geometry>
        <material name="grey"><color rgba="0.7 0.7 0.7 1"/></material>
      </visual>
      <collision>
        <geometry><box size="${size_x} ${size_y} ${size_z}"/></geometry>
      </collision>
      <inertial>
        <mass value="${mass_val}"/>
        <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.001"/>
      </inertial>
    </link>
  </xacro:macro>

  <!-- Base link -->
  <xacro:box_link name="base_link" mass_val="0.5" size_x="0.1" size_y="0.1" size_z="0.1"/>

  <!-- Shoulder link -->
  <xacro:box_link name="shoulder_link" mass_val="1.0" size_x="0.05" size_y="0.05" size_z="0.2"/>
  <joint name="shoulder_joint" type="revolute">
    <parent link="base_link"/>
    <child link="shoulder_link"/>
    <origin xyz="0 0 0.05" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <limit lower="-${pi/2}" upper="${pi/2}" effort="100" velocity="10"/>
  </joint>

  <!-- Elbow link -->
  <xacro:box_link name="elbow_link" mass_val="0.8" size_x="0.04" size_y="0.04" size_z="0.15"/>
  <joint name="elbow_joint" type="revolute">
    <parent link="shoulder_link"/>
    <child link="elbow_link"/>
    <origin xyz="0 0 0.2" rpy="0 0 0"/>
    <axis xyz="0 1 0"/>
    <limit lower="-${pi/2}" upper="${pi/2}" effort="100" velocity="10"/>
  </joint>

</robot>
```
*   **Code Example 4.2**: Xacro file for a 2-DoF arm (shoulder and elbow).

### 4.4 Visual and Collision Geometries: Meshes & Primitives

For a robot model to be useful in visualization and simulation, it needs geometric definitions. URDF distinguishes between **visual** and **collision** geometries.
*   **Visual Geometry**: Defines how the link appears in tools like RViz. This typically uses 3D mesh files (`.stl`, `.dae`, `.obj`) for detailed and realistic rendering.
*   **Collision Geometry**: Defines the shape used by physics engines (e.g., in Gazebo or Isaac Sim) to detect physical contact with other objects or the environment. Collision meshes are often simplified versions of visual meshes (e.g., using primitive shapes like boxes, spheres, cylinders) to reduce computational load for collision detection, while still accurately representing the robot's physical bounds. The quality of collision geometry directly impacts the realism and stability of simulations.

```xml
<link name="humanoid_torso">
  <visual>
    <geometry>
      <!-- Reference a 3D mesh file for detailed visual appearance -->
      <mesh filename="package://humanoid_description/meshes/torso.dae" scale="1 1 1"/>
    </geometry>
    <material name="dark_grey">
      <color rgba="0.2 0.2 0.2 1"/>
    </material>
  </visual>
  <collision>
    <geometry>
      <!-- Use a simplified box primitive for efficient collision detection -->
      <box size="0.3 0.2 0.5"/>
    </geometry>
  </collision>
  <!-- ... inertial and other properties ... -->
</link>
```

### 4.5 Robot Kinematics Fundamentals for Humanoids

**Kinematics** is the study of motion without considering the forces that cause it. For humanoid robots, understanding kinematics is foundational for motion planning, control, and inverse kinematics tasks.
*   **Forward Kinematics (FK)**: Given the joint angles of a robot, FK calculates the position and orientation (pose) of a specific end-effector (e.g., hand, foot). This is a straightforward computation based on the robot's kinematic chain.
*   **Inverse Kinematics (IK)**: Given a desired pose for an end-effector, IK calculates the required joint angles to achieve that pose. This is generally more complex than FK, often involving numerical solvers, and can have multiple solutions or no solutions. For humanoids with many **Degrees of Freedom (DoF)**, IK is vital for tasks like reaching, grasping, and maintaining balance.

<HardwareTrackCallout track="Track B (Jetson/Unitree)">
Accurate URDF models are critical for the on-board kinematics solvers running on platforms like NVIDIA Jetson for real-time control of humanoid robots like the Unitree H1, ensuring that commanded joint movements result in desired end-effector poses.
</HardwareTrackCallout>

### 4.6 Visualizing URDF Models in RViz

**RViz (ROS Visualization)** is an indispensable 3D visualizer for ROS 2. It allows you to display your robot model (loaded from its URDF description), sensor data, and current robot state in a graphical environment. RViz is crucial for debugging your URDF, verifying joint limits, checking coordinate frames, and visualizing motion plans.

To display a URDF model in RViz, you typically need:
1.  **`robot_state_publisher`**: A ROS 2 node that reads the URDF and the current joint states, then publishes the robot's model (TF tree) to RViz.
2.  **`joint_state_publisher_gui`**: A GUI tool that allows you to manually manipulate joint angles and publish their states, enabling interactive testing of your URDF.

```python
# Minimal Python launch file to display a URDF model in RViz
from launch import LaunchDescription
from launch_ros.actions import Node
import os
from ament_index_python.packages import get_package_share_directory

def generate_launch_description():
    # Specify the path to your robot's URDF file
    # Ensure your_robot_description_package/urdf/your_robot.urdf.xacro exists
    robot_description_path = os.path.join(
        get_package_share_directory('your_robot_description_package'),
        'urdf',
        'your_robot.urdf.xacro'
    )

    # Use xacro to process the URDF.xacro file
    robot_description_content = open(robot_description_path).read()
    robot_description = {'robot_description': robot_description_content}

    return LaunchDescription([
        # Robot State Publisher node
        Node(
            package='robot_state_publisher',
            executable='robot_state_publisher',
            output='screen',
            parameters=[robot_description]
        ),
        # Joint State Publisher GUI node (for manual joint control)
        Node(
            package='joint_state_publisher_gui',
            executable='joint_state_publisher_gui',
            name='joint_state_publisher_gui',
            output='screen'
        ),
        # RViz2 node
        Node(
            package='rviz2',
            executable='rviz2',
            name='rviz2',
            output='screen',
            arguments=['-d', os.path.join(get_package_share_directory('your_robot_description_package'), 'rviz', 'your_robot_display.rviz')]
        )
    ])
```
*   **Code Example 4.3**: Launch file to display a URDF model in RViz with `joint_state_publisher_gui`.

### 4.7 Simulating Humanoids in Gazebo and Isaac Sim

Simulation is a crucial step in humanoid robotics development, allowing for safe testing of hardware designs and control algorithms without risking damage to expensive physical robots.
*   **Gazebo**: A popular open-source 3D robotics simulator that provides a robust physics engine, sensor simulation, and environmental interaction. It integrates seamlessly with ROS 2, allowing you to spawn your URDF models and interact with them using ROS 2 nodes.
*   **NVIDIA Isaac Sim**: Built on NVIDIA Omniverse, Isaac Sim is a high-fidelity, GPU-accelerated simulator offering photorealistic rendering and advanced physics. It's particularly well-suited for complex robots like humanoids and for AI training due to its performance and integration capabilities with ROS 2 and USD (Universal Scene Description) assets.

To simulate a robot, you typically write a launch file that:
1.  Starts the simulator (e.g., Gazebo server and client).
2.  Spawns your robot model (from URDF) into the simulation.
3.  Launches controllers (e.g., from `ros2_control`) if you want to actively control the robot.

```python
# Minimal Python launch file to spawn a simple URDF model in Gazebo
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch_ros.actions import Node
import os
from ament_index_python.packages import get_package_share_directory

def generate_launch_description():
    gazebo_ros_dir = get_package_share_directory('gazebo_ros')
    your_robot_description_package = get_package_share_directory('your_robot_description_package')

    robot_description_path = os.path.join(
        your_robot_description_package,
        'urdf',
        'your_robot.urdf.xacro'
    )

    # Process xacro to get the URDF content
    robot_description_content = open(robot_description_path).read()
    robot_description = {'robot_description': robot_description_content}

    return LaunchDescription([
        # Include the Gazebo launch file
        IncludeLaunchDescription(
            PythonLaunchDescriptionSource(os.path.join(gazebo_ros_dir, 'launch', 'gazebo.launch.py')),
            launch_arguments={'gazebo_args': '-s libgazebo_ros_factory.so'}.items(),
        ),

        # Spawn the robot into Gazebo
        Node(
            package='gazebo_ros',
            executable='spawn_entity.py',
            arguments=['-entity', 'my_humanoid_robot', '-topic', 'robot_description'],
            output='screen',
        ),

        # Robot State Publisher (to broadcast TF frames for RViz visualization)
        Node(
            package='robot_state_publisher',
            executable='robot_state_publisher',
            output='screen',
            parameters=[robot_description]
        ),
    ])
```
*   **Code Example 4.4**: Launch file to spawn a simple URDF model in Gazebo.

<HardwareTrackCallout track="Track A (Isaac Sim)">
Isaac Sim provides extensive tools for importing URDF and USD models, configuring physics, and integrating with ROS 2 via `isaac_ros_common`. Its high-fidelity simulation is particularly valuable for complex humanoid dynamics.
</HardwareTrackCallout>

### 4.8 Case Study: Simplified Unitree H1/Figure 01 URDF Structure

To illustrate the complexity of humanoid robot modeling, consider a simplified representation of the Unitree H1 or Figure 01. These robots possess numerous degrees of freedom (DoF) across their legs, torso, and arms, each requiring precise definition of links (e.g., foot, calf, thigh, hip, torso, shoulder, arm, forearm, hand) and joints (e.g., knee, hip_yaw, shoulder_pitch). A full URDF/Xacro for such a robot would involve:
*   A base link (e.g., `base_link` or `torso_link`).
*   Chains for each leg with multiple revolute joints for hip, knee, and ankle movements.
*   Chains for each arm with shoulder, elbow, and wrist joints.
*   A neck and head with appropriate DoF.
*   Inertial properties for all links, often estimated or provided by the manufacturer.
*   Visual and collision meshes for each segment, often imported from CAD models.
The complexity highlights the utility of Xacro for modularity and parameterization.

#### Worked Example 4.1: Building a Complete Xacro Model for a Simplified Humanoid Torso with a Movable Head
(Placeholder for detailed example: This section will guide through creating a Xacro model of a simplified humanoid torso, including a base link, neck joint, and head link, and ensuring it can be visualized in RViz.)

#### Worked Example 4.2: Importing a 3D Mesh for a Robot Link and Visualizing its Collision Geometry
(Placeholder for detailed example: This section will demonstrate how to incorporate a downloaded or custom 3D mesh (e.g., `.dae` file for a robot arm segment) into a URDF, define both its visual and a simplified collision geometry, and verify its appearance and collision bounds in RViz.)

### 4.9 Summary & Key Takeaways

Chapter 4 has equipped you with the essential skills to digitally describe and model humanoid robots using URDF and Xacro. You've mastered the definition of links and joints, understood the critical distinction between visual and collision geometries, and learned how to incorporate 3D meshes for realistic representation. The fundamentals of robot kinematics (FK and IK) were introduced as the basis for understanding robot motion. Finally, you gained practical experience in visualizing your robot models in RViz and integrating them into dynamic simulation environments like Gazebo and NVIDIA Isaac Sim, paving the way for advanced robot development and control. This foundational knowledge is paramount for working with any physical robot system.

### 4.10 Quiz & Exercises

#### Multiple Choice Questions

1.  **Which XML-based file format is used in ROS to describe a robot's kinematic and dynamic properties?**
    a) Xacro
    b) YAML
    c) URDF
    d) SDF

2.  **What is the primary purpose of a `collision` geometry in a URDF model?**
    a) To define the visual appearance of the robot.
    b) To enable efficient physical interaction detection in simulators.
    c) To specify the robot's material properties for rendering.
    d) To describe the robot's sensor placement.

3.  **Which of the following is an advantage of using Xacro over plain URDF for complex robot descriptions?**
    a) Xacro files can be directly loaded into RViz without processing.
    b) Xacro allows for modularity, macros, and parameterized robot definitions.
    c) Xacro is primarily used for defining robot controllers, not physical structure.
    d) Xacro eliminates the need for 3D mesh files.

4.  **Given the joint angles of a robot, which type of kinematics calculates the position and orientation of a specific end-effector?**
    a) Inverse Kinematics (IK)
    b) Forward Kinematics (FK)
    c) Differential Kinematics
    d) Resolved-Rate Kinematics

5.  **Which ROS 2 tool is essential for visualizing URDF models, sensor data, and planned paths in a 3D environment?**
    a) Gazebo
    b) Isaac Sim
    c) `colcon`
    d) RViz

#### Open-ended Question

1.  Explain the importance of distinguishing between visual and collision geometries in URDF models, especially in the context of humanoid robot simulation. Provide examples of when you might use a simplified primitive shape for collision and a detailed mesh for visual representation.

### 4.11 References

*   ROS 2 Documentation. (n.d.-a). *URDF*. Retrieved from [https://docs.ros.org/en/humble/Tutorials/URDF/URDF-Main.html](https://docs.ros.org/en/humble/Tutorials/URDF/URDF-Main.html)
*   ROS 2 Documentation. (n.d.-b). *Xacro*. Retrieved from [https://docs.ros.org/en/humble/Tutorials/URDF/Using-Xacro-to-Clean-Up-a-URDF.html](https://docs.ros.org/en/humble/Tutorials/URDF/Using-Xacro-to-Clean-Up-a-URDF.html)
*   ROS 2 Documentation. (n.d.-c). *robot_state_publisher*. Retrieved from [https://docs.ros.org/en/humble/Tutorials/URDF/The-robot_state_publisher-Package.html](https://docs.ros.org/en/humble/Tutorials/URDF/The-robot_state_publisher-Package.html)
*   ROS 2 Documentation. (n.d.-d). *joint_state_publisher*. Retrieved from [https://docs.ros.org/en/humble/Tutorials/URDF/The-joint_state_publisher-Package.html](https://docs.ros.org/en/humble/Tutorials/URDF/The-joint_state_publisher-Package.html)
*   NVIDIA. (n.d.). *NVIDIA Isaac Sim*. Retrieved from [https://developer.nvidia.com/isaac-sim](https://developer.nvidia.com/isaac-sim)
*   Gazebo Documentation. (n.d.). *Gazebo ROS 2 Tutorials*. Retrieved from [https://classic.gazebosim.org/tutorials?cat=ros2](https://classic.gazebosim.org/tutorials?cat=ros2)
*   Siciliano, B., Sciavicco, L., Villani, L., & Oriolo, G. (2009). *Robotics: Modelling, Planning and Control*. Springer. (Cited for general robotics kinematics reference).
